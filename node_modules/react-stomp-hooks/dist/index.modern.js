import React, { createContext, useState, useRef, useEffect, useContext } from 'react';
import SockJS from 'sockjs-client';
import { Client } from '@stomp/stompjs';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const StompContext = createContext(undefined);

const _excluded = ["url", "children", "stompClientOptions"];
/**
 * The StompSessionProvider manages the STOMP connection
 * All Hooks and HOCs in this library require an ancestor of this type.
 * The URL to connect to can be specified via the url prop.
 * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.
 * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs
 * Custom @stomp/stompjs options can be used as props.
 * Please consult the @stomp/stompjs documentation for more information.
 */

function StompSessionProvider(props) {
  let {
    url,
    children,
    stompClientOptions
  } = props,
      stompOptions = _objectWithoutPropertiesLoose(props, _excluded); // Support old API


  if (stompClientOptions) stompOptions = stompClientOptions;
  const [client, setClient] = useState(undefined);
  const subscriptionRequests = useRef(new Map());
  useEffect(() => {
    const _client = new Client(stompOptions);

    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {
      _client.webSocketFactory = function () {
        var _window, _window$location;

        const parsedUrl = new URL(url, (_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.href);

        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {
          return new SockJS(url);
        } else if (parsedUrl.protocol === 'ws:' || parsedUrl.protocol === 'wss:') {
          return new WebSocket(url);
        } else throw new Error('Protocol not supported');
      };
    }

    _client.onConnect = function (frame) {
      if (stompOptions.onConnect) stompOptions.onConnect(frame);
      subscriptionRequests.current.forEach(value => {
        value.subscription = _client.subscribe(value.destination, value.callback, value.headers);
      });
      setClient(_client);
    };

    _client.onWebSocketClose = function (event) {
      if (stompOptions.onWebSocketClose) stompOptions.onWebSocketClose(event);
      setClient(undefined);
    };

    if (!stompOptions.onStompError) {
      _client.onStompError = function (frame) {
        throw frame;
      };
    }

    _client.activate();

    return () => {
      _client.deactivate();
    };
  }, [url, ...Object.values(stompOptions)]);

  const subscribe = (destination, callback, headers = {}) => {
    const subscriptionId = Math.random().toString(36).substr(2, 9);
    const subscriptionRequest = {
      destination,
      callback,
      headers
    };
    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);

    if (client && client.connected) {
      subscriptionRequest.subscription = client.subscribe(destination, callback, headers);
    }

    return () => {
      const subscriptionData = subscriptionRequests.current.get(subscriptionId);

      if (subscriptionData.subscription) {
        subscriptionData.subscription.unsubscribe();
      }

      subscriptionRequests.current.delete(subscriptionId);
    };
  };

  return React.createElement(StompContext.Provider, {
    value: {
      client,
      subscribe
    }
  }, children);
}

/**
 *
 * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.
 * @param onMessage Callback called when a message arrives for this subscription
 * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.
 */

function useSubscription(destinations, onMessage, headers = {}) {
  const stompContext = useContext(StompContext);
  if (stompContext === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');
  const callbackRef = useRef(onMessage);

  const _destinations = Array.isArray(destinations) ? destinations : [destinations];

  callbackRef.current = onMessage;
  useEffect(() => {
    const cleanUpFunctions = [];

    _destinations.forEach(_destination => cleanUpFunctions.push(stompContext.subscribe(_destination, message => {
      callbackRef.current(message);
    }, headers)));

    return () => {
      cleanUpFunctions.forEach(_cleanUpFunction => {
        _cleanUpFunction();
      });
    };
  }, [Object.values(_destinations).toString(), Object.values(headers).toString()]);
}

/**
 * Returns the Stomp Client from @stomp/stompjs
 * This will be undefined if the client is currently not connected
 */

function useStompClient() {
  const context = useContext(StompContext);
  if (context === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');
  return context.client;
}

function withStompClient(WrappedComponent) {
  return props => {
    const stompClient = useStompClient();
    return React.createElement(WrappedComponent, Object.assign({
      stompClient: stompClient
    }, props));
  };
}

function withSubscription(WrappedComponent, destinations, headers = {}) {
  return props => {
    const ref = useRef();
    useSubscription(destinations, message => {
      if (ref.current) ref.current.onMessage(message);
    }, headers); // @ts-ignore

    return React.createElement(WrappedComponent, Object.assign({
      ref: ref
    }, props));
  };
}

const subscriptions = new Map();
function subscribeMock(destination, callback, // @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
headers = {}) {
  const subscriptionId = Math.random().toString(36).substr(2, 9);

  if (!subscriptions.has(destination)) {
    subscriptions.set(destination, new Map());
  } // @ts-ignore


  subscriptions.get(destination).set(subscriptionId, callback);
  return () => {
    // @ts-ignore
    subscriptions.get(destination).delete(subscriptionId);
  };
}
/**
 * Simulates receiving a message from the server to the specified destination
 * @param destination The topic to send the message to
 * @param message The message to send
 */

function mockReceiveMessage(destination, message) {
  if (subscriptions.has(destination)) {
    // @ts-ignore
    subscriptions.get(destination).forEach(callback => {
      callback(message);
    });
  }
}
/**
 * Gets the current subscriptions for the specified destination
 * @param destination The topic to get the subscriptions for, or undefined to get all subscriptions
 */

function getMockSubscriptions(destination) {
  if (destination) {
    return subscriptions.get(destination);
  }

  return subscriptions;
}

const messages = new Map();
/**
 * A mock implementation of the publish function of the @stomp/stompjs client.
 * Will store the messages in a map, keyed by the destination.
 * @param params
 */

function mockClientPublish(params) {
  if (!messages.has(params.destination)) {
    messages.set(params.destination, []);
  } // @ts-ignore


  messages.get(params.destination).push(params);
}
/**
 * Gets a default Mock of the @stomp/stompjs client.
 * If you require a custom client, you can use this as a base.
 */

function getMockClient() {
  return {
    publish: mockClientPublish
  };
}
/**
 * Gets all messages which have been sent via a mock client.
 * @param destination The destination to get messages for, or undefined to get all messages.
 */

function getSentMockMessages(destination) {
  if (destination) {
    return messages.get(destination);
  }

  return messages;
}

/**
 * A mock StompSessionProvider.
 * Messages send via this mock implementation can be received via the getSentMockMessages method.
 * Subscriptions can be received via the getMockSubscriptions method.
 * The sendMockMessage method can be used, to simulate receiving a message from the server.
 *
 * @param props.client Optional. Can be used to provide a custom mock of the sompjs client,
 * in case you require additional properties/functions to be present. getMockClient can be used as a base.
 * @constructor
 */

function StompSessionProviderMock(props) {
  var _props$client;

  return React.createElement(StompContext.Provider, {
    value: {
      subscribe: subscribeMock,
      // @ts-ignore
      client: (_props$client = props.client) != null ? _props$client : getMockClient()
    }
  }, props.children);
}

/**
 * Resets the state of the mock implementation, clearing all subscriptions and messages.
 */

function reset() {
  subscriptions.clear();
  messages.clear();
}

var index = {
  __proto__: null,
  StompSessionProviderMock: StompSessionProviderMock,
  getMockClient: getMockClient,
  mockClientPublish: mockClientPublish,
  mockReceiveMessage: mockReceiveMessage,
  getSentMockMessages: getSentMockMessages,
  reset: reset,
  getMockSubscriptions: getMockSubscriptions
};

export { StompSessionProvider, index as mock, useStompClient, useSubscription, withStompClient, withSubscription };
//# sourceMappingURL=index.modern.js.map
